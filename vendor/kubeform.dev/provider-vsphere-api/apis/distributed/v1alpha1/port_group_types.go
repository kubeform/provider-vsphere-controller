/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type PortGroup struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              PortGroupSpec   `json:"spec,omitempty"`
	Status            PortGroupStatus `json:"status,omitempty"`
}

type PortGroupSpecVlanRange struct {
	// The minimum VLAN to use in the range.
	MaxVLAN *int64 `json:"maxVLAN" tf:"max_vlan"`
	// The minimum VLAN to use in the range.
	MinVLAN *int64 `json:"minVLAN" tf:"min_vlan"`
}

type PortGroupSpec struct {
	State *PortGroupSpecResource `json:"state,omitempty" tf:"-"`

	Resource PortGroupSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type PortGroupSpecResource struct {
	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +optional
	ActiveUplinks []string `json:"activeUplinks,omitempty" tf:"active_uplinks"`
	// Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.
	// +optional
	AllowForgedTransmits *bool `json:"allowForgedTransmits,omitempty" tf:"allow_forged_transmits"`
	// Controls whether or not the Media Access Control (MAC) address can be changed.
	// +optional
	AllowMACChanges *bool `json:"allowMACChanges,omitempty" tf:"allow_mac_changes"`
	// Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.
	// +optional
	AllowPromiscuous *bool `json:"allowPromiscuous,omitempty" tf:"allow_promiscuous"`
	// Auto-expands the port group beyond the port count configured in number_of_ports when necessary.
	// +optional
	AutoExpand *bool `json:"autoExpand,omitempty" tf:"auto_expand"`
	// Indicates whether to block all ports by default.
	// +optional
	BlockAllPorts *bool `json:"blockAllPorts,omitempty" tf:"block_all_ports"`
	// Allow the blocked setting of an individual port to override the setting in the portgroup.
	// +optional
	BlockOverrideAllowed *bool `json:"blockOverrideAllowed,omitempty" tf:"block_override_allowed"`
	// Enable beacon probing on the ports this policy applies to.
	// +optional
	CheckBeacon *bool `json:"checkBeacon,omitempty" tf:"check_beacon"`
	// Version string of the configuration that this spec is trying to change.
	// +optional
	ConfigVersion *string `json:"configVersion,omitempty" tf:"config_version"`
	// A list of custom attributes to set on this resource.
	// +optional
	CustomAttributes *map[string]string `json:"customAttributes,omitempty" tf:"custom_attributes"`
	// The description of the portgroup.
	// +optional
	Description *string `json:"description,omitempty" tf:"description"`
	// Allow VMDirectPath Gen2 on the ports this policy applies to.
	// +optional
	DirectpathGen2Allowed *bool `json:"directpathGen2Allowed,omitempty" tf:"directpath_gen2_allowed"`
	// The UUID of the DVS to attach this port group to.
	DistributedVirtualSwitchUUID *string `json:"distributedVirtualSwitchUUID" tf:"distributed_virtual_switch_uuid"`
	// The average egress bandwidth in bits per second if egress shaping is enabled on the port.
	// +optional
	EgressShapingAverageBandwidth *int64 `json:"egressShapingAverageBandwidth,omitempty" tf:"egress_shaping_average_bandwidth"`
	// The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.
	// +optional
	EgressShapingBurstSize *int64 `json:"egressShapingBurstSize,omitempty" tf:"egress_shaping_burst_size"`
	// True if the traffic shaper is enabled for egress traffic on the port.
	// +optional
	EgressShapingEnabled *bool `json:"egressShapingEnabled,omitempty" tf:"egress_shaping_enabled"`
	// The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.
	// +optional
	EgressShapingPeakBandwidth *int64 `json:"egressShapingPeakBandwidth,omitempty" tf:"egress_shaping_peak_bandwidth"`
	// If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.
	// +optional
	Failback *bool `json:"failback,omitempty" tf:"failback"`
	// The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.
	// +optional
	IngressShapingAverageBandwidth *int64 `json:"ingressShapingAverageBandwidth,omitempty" tf:"ingress_shaping_average_bandwidth"`
	// The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.
	// +optional
	IngressShapingBurstSize *int64 `json:"ingressShapingBurstSize,omitempty" tf:"ingress_shaping_burst_size"`
	// True if the traffic shaper is enabled for ingress traffic on the port.
	// +optional
	IngressShapingEnabled *bool `json:"ingressShapingEnabled,omitempty" tf:"ingress_shaping_enabled"`
	// The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.
	// +optional
	IngressShapingPeakBandwidth *int64 `json:"ingressShapingPeakBandwidth,omitempty" tf:"ingress_shaping_peak_bandwidth"`
	// The generated UUID of the portgroup.
	// +optional
	Key *string `json:"key,omitempty" tf:"key"`
	// Whether or not to enable LACP on all uplink ports.
	// +optional
	LacpEnabled *bool `json:"lacpEnabled,omitempty" tf:"lacp_enabled"`
	// The uplink LACP mode to use. Can be one of active or passive.
	// +optional
	LacpMode *string `json:"lacpMode,omitempty" tf:"lacp_mode"`
	// Allow a live port to be moved in and out of the portgroup.
	// +optional
	LivePortMovingAllowed *bool `json:"livePortMovingAllowed,omitempty" tf:"live_port_moving_allowed"`
	// The name of the portgroup.
	Name *string `json:"name" tf:"name"`
	// Indicates whether to enable netflow on all ports.
	// +optional
	NetflowEnabled *bool `json:"netflowEnabled,omitempty" tf:"netflow_enabled"`
	// Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup.
	// +optional
	NetflowOverrideAllowed *bool `json:"netflowOverrideAllowed,omitempty" tf:"netflow_override_allowed"`
	// The key of a network resource pool to associate with this portgroup.
	// +optional
	NetworkResourcePoolKey *string `json:"networkResourcePoolKey,omitempty" tf:"network_resource_pool_key"`
	// Allow the network resource pool of an individual port to override the setting in the portgroup.
	// +optional
	NetworkResourcePoolOverrideAllowed *bool `json:"networkResourcePoolOverrideAllowed,omitempty" tf:"network_resource_pool_override_allowed"`
	// If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.
	// +optional
	NotifySwitches *bool `json:"notifySwitches,omitempty" tf:"notify_switches"`
	// The number of ports in this portgroup. The DVS will expand and shrink by modifying this setting.
	// +optional
	NumberOfPorts *int64 `json:"numberOfPorts,omitempty" tf:"number_of_ports"`
	// Reset the setting of any ports in this portgroup back to the default setting when the port disconnects.
	// +optional
	PortConfigResetAtDisconnect *bool `json:"portConfigResetAtDisconnect,omitempty" tf:"port_config_reset_at_disconnect"`
	// A template string to use when creating ports in the portgroup.
	// +optional
	PortNameFormat *string `json:"portNameFormat,omitempty" tf:"port_name_format"`
	// The secondary VLAN ID for this port.
	// +optional
	PortPrivateSecondaryVLANID *int64 `json:"portPrivateSecondaryVLANID,omitempty" tf:"port_private_secondary_vlan_id"`
	// Allow security policy settings on a port to override those on the portgroup.
	// +optional
	SecurityPolicyOverrideAllowed *bool `json:"securityPolicyOverrideAllowed,omitempty" tf:"security_policy_override_allowed"`
	// Allow the traffic shaping policies of an individual port to override the settings in the portgroup.
	// +optional
	ShapingOverrideAllowed *bool `json:"shapingOverrideAllowed,omitempty" tf:"shaping_override_allowed"`
	// List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.
	// +optional
	StandbyUplinks []string `json:"standbyUplinks,omitempty" tf:"standby_uplinks"`
	// A list of tag IDs to apply to this object.
	// +optional
	Tags []string `json:"tags,omitempty" tf:"tags"`
	// The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.
	// +optional
	TeamingPolicy *string `json:"teamingPolicy,omitempty" tf:"teaming_policy"`
	// Allow any filter policies set on the individual port to override those in the portgroup.
	// +optional
	TrafficFilterOverrideAllowed *bool `json:"trafficFilterOverrideAllowed,omitempty" tf:"traffic_filter_override_allowed"`
	// If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.
	// +optional
	TxUplink *bool `json:"txUplink,omitempty" tf:"tx_uplink"`
	// The type of portgroup. Can be one of earlyBinding (static) or ephemeral.
	// +optional
	Type *string `json:"type,omitempty" tf:"type"`
	// Allow the uplink teaming policies on a port to override those on the portgroup.
	// +optional
	UplinkTeamingOverrideAllowed *bool `json:"uplinkTeamingOverrideAllowed,omitempty" tf:"uplink_teaming_override_allowed"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +optional
	VlanID *int64 `json:"vlanID,omitempty" tf:"vlan_id"`
	// Allow the VLAN configuration on a port to override those on the portgroup.
	// +optional
	VlanOverrideAllowed *bool `json:"vlanOverrideAllowed,omitempty" tf:"vlan_override_allowed"`
	// The VLAN ID for single VLAN mode. 0 denotes no VLAN.
	// +optional
	VlanRange []PortGroupSpecVlanRange `json:"vlanRange,omitempty" tf:"vlan_range"`
}

type PortGroupStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// PortGroupList is a list of PortGroups
type PortGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of PortGroup CRD objects
	Items []PortGroup `json:"items,omitempty"`
}
